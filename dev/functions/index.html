<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · LLLplus.jl</title><meta name="title" content="Functions · LLLplus.jl"/><meta property="og:title" content="Functions · LLLplus.jl"/><meta property="twitter:title" content="Functions · LLLplus.jl"/><meta name="description" content="Documentation for LLLplus.jl."/><meta property="og:description" content="Documentation for LLLplus.jl."/><meta property="twitter:description" content="Documentation for LLLplus.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LLLplus.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LLLplus.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Functions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/chrisvwx/LLLplus.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/chrisvwx/LLLplus.jl/blob/main/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="LLLplus.lll"><a class="docstring-binding" href="#LLLplus.lll"><code>LLLplus.lll</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">B,T,Q,R = lll(H,δ=3/4)</code></pre><p>Do Lenstra–Lenstra–Lovász lattice reduction of the basis defined by the columns of <code>H</code> using optional parameter <code>δ</code>.  The output is <code>B</code>, an LLL-reduced basis; <code>T</code>, a unimodular (meaning <code>det(T)=+/-1</code>) transformation matrix such that <code>B= H*T</code>; and finally <code>Q</code> and <code>R</code> which are a QR decomposition of <code>B</code>.  So <code>H = B*inv(T) = Q*R*inv(T)</code>.</p><p>Follows D. Wuebben, et al, &quot;Lattice Reduction - A Survey with Applications in Wireless Communications&quot;, IEEE Signal Processing Magazine, Apr 2011.  http://www.ant.uni-bremen.de/sixcms/media.php/102/10740/SPM<em>2011</em>Wuebben.pdf</p><p>The LLL tecnique was originally described in &quot;Factoring polynomials with rational coefficients&quot; by A. K. Lenstra, H. W. Lenstra Jr. and L. Lovász, Mathematische Annalen 261, 1982. http://ftp.cs.elte.hu/~lovasz/scans/lll.pdf</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];B,_ = lll(H); B
2×2 Matrix{Int64}:
 1  -1
 1   1

julia&gt; H= BigFloat.([1.5 2; 3 4]) .+ 2im; B,_= lll(H); B
2×2 Matrix{Complex{BigFloat}}:
 0.5+0.0im  0.0+1.0im
 1.0+0.0im  0.0+0.0im

julia&gt; N=500;H = randn(N,N); B,T = lll(H);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/lll.jl#L1-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.cvp"><a class="docstring-binding" href="#LLLplus.cvp"><code>LLLplus.cvp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">u=cvp(y,R,...)</code></pre><p>This function is deprecated and will likely have its return value change in the future; please use <code>cvpRu</code> if you want to keep the previous return API.</p><p>&quot;CVP&quot; stands for &quot;closest vector problem.&quot;  Unfortunately, at present this function does not return the closest vector to <code>y</code> in the lattice <code>R</code>, but the integer vector <code>u</code> such that multiplying the basis <code>R</code> by this integer vector (i.e. <code>Ru</code>) gives the closest vector. To avoid confusion, in the future the return value will be changed to be <code>Ru</code>, i.e. the closest vector.</p><p>Switch to the function <code>cvpu</code> to get <code>u</code> as the return value, and the function <code>cvpRu</code> to get the closest vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/cvp.jl#L1-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.brun"><a class="docstring-binding" href="#LLLplus.brun"><code>LLLplus.brun</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">B, T = brun(H)</code></pre><p>Brun&#39;s integer-relations alg implemented as a matrix decomposition. Takes as input the matrix <code>H</code> and returns a reduced basis <code>B</code> and <code>T</code>, a unimodular transformation matrix such that <code>B = H*T</code>. Brun reduction is often done with <code>pinv(H)</code> as input to yield <code>B = pinv(H)*T</code>.</p><p>See V. Brun, &quot;En generalisation av kjedebrøken I,&quot; Skr. Vid ensk. Selsk. Kristiana, Mat. Nat. Klasse, 1919.  See https://archive.org/stream/skrifterutgitavv201chri#page/300/mode/2up</p><p>Follows code from D. Wuebben, D. Seethaler, J. Jalden, and G. Matz, &quot;Lattice Reduction - A Survey with Applications in Wireless Communications&quot; IEEE Signal Processing Magazine, March 2011</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H=[1 2; 3 4]; B,T=brun(H); T
2×2 Matrix{Int64}:
  3  -1
 -2   1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/brun.jl#L1-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.gauss"><a class="docstring-binding" href="#LLLplus.gauss"><code>LLLplus.gauss</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">B = gauss(H)</code></pre><p>Do Gauss/Lagrange reduction on the lattice defined by the two columns of H.</p><p>Follows Fig 2.3 of &quot;Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications&quot; by Murray R. Bremner, CRC Press, 2012.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H = [1 2; 3 3]; B = gauss(H)
2×2 Matrix{Float64}:
 1.0  0.0
 0.0  3.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/lll.jl#L106-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.seysen"><a class="docstring-binding" href="#LLLplus.seysen"><code>LLLplus.seysen</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">B,T,B_dual,num_it = seysen(H::Array{Td,2}) where Td</code></pre><p>Do greedy  Seysen lattice reduction  on the  matrix <code>H</code>, returning  <code>B</code>, the reduced lattice basis;  <code>T</code> a unimodular matrix that reduces  <code>H</code> (i.e. <code>B = H*T</code>); <code>B_dual</code>, dual lattice basis (i.e., <code>B_dual = pinv(B)</code>); and num_it the number of iterations (basis updates). See also <a href="#LLLplus.lll"><code>lll</code></a>.</p><p>Follows Seysen algorithm in &quot;Lattice Reduction - A Survey with Applications in Wireless Communications&quot; by D. Wuebben, et al, IEEE Signal Processing Magazine, 2011.</p><p>Technique originally described in &quot;Simultaneous reduction of a lattice basis and its reciprocal basis&quot; by M. Seysen, Combinatorica, 1993. http://link.springer.com/article/10.1007%2FBF01202355</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];B,T = seysen(H); B
2×2 Matrix{Int64}:
 -1  1
  1  1

julia&gt; H= BigFloat.([1.5 2; 3 4]) .+ 2im; B,_= seysen(H); B
2×2 Matrix{Complex{BigFloat}}:
 0.0+1.0im  0.5+0.0im
 0.0+0.0im  1.0+0.0im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/seysen.jl#L1-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.vblast"><a class="docstring-binding" href="#LLLplus.vblast"><code>LLLplus.vblast</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">W,P,B = vblast(H)</code></pre><p>Find a VBLAST decomposition of <code>H</code> such that <code>H = pinv(W)*B*P&#39;</code> or <code>B = W*H*P</code>.  Here <code>P</code> is a permutation matrix, <code>B</code> is lower triangular with ones on the diagonal, and <code>W</code> has orthogonal rows.</p><pre><code class="language-julia hljs">W,P,B = vblast(H,mu)</code></pre><p>If an SNR argument <code>mu</code> is passed in, a regularized (&quot;MMSE&quot;) decomposition is done, with the result that <code>W</code> will no longer have orthogonal rows and <code>B</code> is no longer lower triangular.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1. 2; 3 4];W,_ = vblast(H); W
2×2 Matrix{Float64}:
 1.5  -0.5
 0.1   0.3

julia&gt; H= BigFloat.([1.5 2; 3 4]) .+ 2im; W,_= vblast(H); W
2×2 Matrix{Complex{BigFloat}}:
      -2.0+3.0im            2.0-1.5im     
 0.0779221-0.103896im  0.155844-0.103896im
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/vblast.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.subsetsum"><a class="docstring-binding" href="#LLLplus.subsetsum"><code>LLLplus.subsetsum</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">x = subsetsum(a,s)</code></pre><p>For a vector of integers <code>a</code>, and an integer <code>s</code>, try to find a binary vector <code>x</code> such that <code>x&#39;*a=s</code>. We use the LLL algorithm to find the solution. This is not a robust tool, just a demo.</p><p>This function tries first the technique in the <code>lagariasodlyzko</code> function, and if it fails, a solution via <code>mdsubsetsum</code> is attempted.</p><p>It appears that this function can also solve some integer relations problems. See the first example.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a=[1.5;.5;0;.1;.2]; s=2.2; x,_=subsetsum(a,s,true); s-x&#39;*a
A binary Lagarias-Odlyzko solution was found.
A solution was found via lagariasodlyzko
0.0

julia&gt; a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117
          2097523,4195057,8390143,16780259,33560539,
          67121039,134242091,268484171,536968403];

julia&gt; s=891221976; x,_=subsetsum(a,s,false); s-x&#39;*a
0

julia&gt; N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a&#39;*xtrue;

julia&gt; setprecision(BigFloat,300); x,_=subsetsum(a,s,false); s-x&#39;*a
0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/applications.jl#L74-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.lagariasodlyzko"><a class="docstring-binding" href="#LLLplus.lagariasodlyzko"><code>LLLplus.lagariasodlyzko</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">x = lagariasodlyzko(a,s)</code></pre><p>For a vector of integers <code>a</code>, and an integer <code>s</code>, try to find a binary vector <code>x</code> such that <code>x&#39;*a=s</code>. We use the LLL algorithm to find the solution. This is not a robust tool, just a demo.</p><p>This follows the technique described by Lagarias and Odlyzko  in  &quot;Solving Low-Density Subset Sum Problems&quot;  in Journal of ACM, Jan 1985. Code based on http://web.eecs.umich.edu/~cpeikert/lic15/lec05.pdf We can likely get better results using techniques described and referenced in https://www-almasty.lip6.fr/~joux/pages/papers/ToolBox.pdf</p><p>It&#39;s odd that permuting the <code>a</code> vector in the second example given below causes the alg to often not find a binary solution. Apparently this is a common oddity with lattice solvers.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a=[1.5;.5;0;.1;.2]; s=2.2; x,_=lagariasodlyzko(a,s); s-x&#39;*a
0.0

julia&gt; a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117
          2097523,4195057,8390143,16780259,33560539,
          67121039,134242091,268484171,536968403];

julia&gt; s=891221976; x,_=lagariasodlyzko(a,s); s-x&#39;*a
0

julia&gt; N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a&#39;*xtrue; 

julia&gt; setprecision(BigFloat,300); x,_=lagariasodlyzko(a,s); s-x&#39;*a
0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/applications.jl#L133-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.mdsubsetsum"><a class="docstring-binding" href="#LLLplus.mdsubsetsum"><code>LLLplus.mdsubsetsum</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">x = mdsubsetsum(a,sM,ratio=.5,Kpm=3)</code></pre><p>For a vector of integers <code>a</code>, and an integer <code>sM</code>, try to find a binary vector <code>x</code> such that <code>x&#39;*a=sM</code> using the technique from &quot;Multidimensional subset sum problem&quot; [1][2]. A major goal of the technique is to solve problems in which there are about 50% ones in <code>x</code>; other ratios of ones to zeros can be specified in <code>ratio</code>.  The thesis also suggests searching <code>Kpm=3</code> values around the nominal k. This technique is related to that in <a href="#LLLplus.subsetsum"><code>subsetsum</code></a> in that both use the LLL algorithm.  This is not a robust tool, just a demo.</p><p>[1] https://scholarworks.rit.edu/theses/64/</p><p>[2] https://pdfs.semanticscholar.org/21a7/c2f9ff29507f1153aefcca04d1cd308e45c0.pdf</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Random, LLLplus

julia&gt; a=[1.5;.5;0;.1;.2]; s=2.2; x=mdsubsetsum(a,s); s-x&#39;*a
0.0

julia&gt; a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117
          2097523,4195057,8390143,16780259,33560539,
          67121039,134242091,268484171,536968403];

julia&gt; sM=891221976; x=mdsubsetsum(a,sM); sM-x&#39;*a
0

julia&gt; setprecision(BigFloat,300); Random.seed!(0);

julia&gt; N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a&#39;*xtrue;

julia&gt; x=mdsubsetsum(a,s); s-x&#39;*a
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/applications.jl#L249-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.integerfeasibility"><a class="docstring-binding" href="#LLLplus.integerfeasibility"><code>LLLplus.integerfeasibility</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">integerfeasibility(A,d)</code></pre><p>Given matrix <code>A</code> and vector <code>d</code>, return an integer vector <code>x</code> which satisfies the system <code>Ax=d</code>.</p><pre><code class="language-julia hljs">integerfeasibility(A,d,true)</code></pre><p>If the third argument is present and is <code>true</code>, then as well as returning a solution <code>x</code>, also return a matrix <code>xNull</code> of vectors in the null space of <code>A</code> which could be added to the <code>x</code> vector to find a solution which satisfies a constraint such as <code>0 .≤ x .≤ u</code>; see the paper below.</p><p>This is not a robust tool, just a demo.</p><p>&quot;Solving A System Of Diophantine Equations With Bounds On The Variables&quot; by Karen Aardal, Cor Hurkens, and Arjen Lenstra in Integer Programming and Combinatorial Optimization, 6th International IPCO Conference, vol 1412, pp 229-242, 1998. See http://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR98782.pdf</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A=[10 1 -9; 1 8 8]; xtrue=[0; 2; 9]; d=A*xtrue;

julia&gt; integerfeasibility(A,d)
3-element Vector{Int64}:
 0
 2
 9

julia&gt; A=[10 1.1 -9.1; 1 8 8]; d=A*xtrue;

julia&gt; integerfeasibility(A,d)
3-element Vector{Float64}:
 0.0
 2.0
 9.0

julia&gt; n=20;m=30; A = rand(-10:10,n,m); xtrue = rand(0:10,m); d=A*xtrue;

julia&gt; sum(abs.(xtrue - integerfeasibility(A,d) ))
0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/applications.jl#L1-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.rationalapprox"><a class="docstring-binding" href="#LLLplus.rationalapprox"><code>LLLplus.rationalapprox</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rationalapprox(x::AbstractArray{&lt;:Real,1},M,Ti=BigInt,verbose=false)</code></pre><p>For a vector of Reals <code>x</code>, and an integer <code>M</code>, find an integer q such that <code>maximum(abs.(x*q-round.(x*q)))</code> is small; the vector <code>x</code> is approximated by <code>round.(x*q)//q</code>.  The integer <code>q</code> is less than or equal to <code>M</code> and the approximation satisfies <code>max(abs.(x*q-round.(x*q)))≤sqrt(5)*2^(n/4 - 5)*M^(-1/n)</code>; this equation comes from the paper below.  The LLL algorithm reduction is used to find the solution. The approximation vector is returned. This is also known as &quot;simultaneous diophantine approximation&quot;; see for example the Hanrot paper below.</p><p>This is not a robust tool, just a demo.</p><p>&quot;LLL: A Tool for Effective Diophantine Approximation&quot; by Guillaume Hanrot in the book &quot;The LLL Algorithm: Survey and Applications&quot; edited by Phong Q. Nguyen and Brigitte Vallée, Springer, Heidelberg, 2010.</p><p>See also Chapter 9 of M. R. Bremner, &quot;Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications&quot; CRC Press, 2012.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = [0.3912641745333527; 0.5455179974014548; 0.1908698210882469];

julia&gt; rationalapprox(x,1e4,Int64)
3-element Vector{Rational{Int64}}:
 43//110
  6//11
 21//110
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/applications.jl#L324-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.spigotBBP"><a class="docstring-binding" href="#LLLplus.spigotBBP"><code>LLLplus.spigotBBP</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">spigotBBP(α::Td,s,b,n,K,verbose=false) where {Td}</code></pre><p>Check for a BBP-style [1] infinite series for the constant <code>α</code>.  These are &quot;spigot&quot; formulas that can be used to generate (for example) the millionth digit of the constant <code>α</code> without learning the previous digits. Specifically, given the constant <code>α</code>, and parameters <code>b</code>, <code>n</code>, and <code>s</code>, look for a vector of numbers <code>a_1</code> through <code>a_n</code> that satisfies the following equation:</p><p><span>$\alpha= \sum_{k=0}^\infty \frac{1}{b^k} \left( \frac{a_1}{(nk+1)^s} + \ldots + \frac{a_n}{(nk+n)^s} \right)$</span></p><p>Because it&#39;s hard to sum to infinity, the sum is stopped at K. If a formula is found, it is printed to the screen in LaTeX and the coefficents <code>a</code> are returned as a vector.  An online LaTeX viewer such as https://www.latex4technics.com/ may be helpful.</p><p>This is not a robust tool, just a demo. For example, there may be a  problem with s≥2. See [2] for derivation of the technique used, and to  check whether a formula you find is new.</p><p>[1] David Bailey, Peter Borwein, and Simon Plouffe. &quot;On the rapid computation of various polylogarithmic constants.&quot; Mathematics of Computation 66.218 (1997): 903-913. https://www.ams.org/journals/mcom/1997-66-218/S0025-5718-97-00856-9/</p><p>[2] David Bailey, &quot;A Compendium of BBP-Type Formulas for Mathematical Constants&quot;. https://www.davidhbailey.com//dhbpapers/bbp-formulas.pdf</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; spigotBBP(BigFloat(pi),1,16,8,45,true);
A solution was found w error -4.728672e-60. In LaTeX form it is
\alpha= \sum_{k=0}^\infty \frac{1}{16^k} \left(\frac{4}{8k+1}-\frac{2}{8k+4}-\frac{1}{8k+5}-\frac{1}{8k+6}\right)</code></pre><p>Other examples without output:</p><pre><code class="language-julia hljs">spigotBBP(Float64(pi),1,-4,4,22,true);
spigotBBP(log(2),1,2,2,30,true);
spigotBBP(9*log(3),1,9,2,30,true);
spigotBBP(atan(2)*8,1,16,8,30,true);
spigotBBP(8*sqrt(2)*log(1+sqrt(2)),1,16,8,25,true);</code></pre><p>There is a formula for pi^2 which the following command should find, but it does not find it. In fact the technique doesn&#39;t seem to work at all for  s&gt;2; It&#39;s not obvious what the problem is</p><pre><code class="language-julia hljs">spigotBBP(BigFloat(pi)*pi,2,64,6,25,true);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/applications.jl#L421-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.minimalpolynomial"><a class="docstring-binding" href="#LLLplus.minimalpolynomial"><code>LLLplus.minimalpolynomial</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">minimalpolynomial(d,β::Td,p,verbose=false) where {Td&lt;:Number}</code></pre><p>Find the minimal polynomial for some element &#39;α&#39; of a field given the degree &#39;d&#39; of the polynomial, an approximation &#39;β&#39; of &#39;α&#39;, and the number of significant (decimal) digits of precision &#39;p&#39; in &#39;β&#39;. Returns two things, a function, and a Bool indicating whether we think a true minimal polynomial was found.  The ouptut function takes a single argument of the same type as &#39;β&#39;, and evaluates the estimated minimal polynomial over that argument.</p><p>Follows technique in the following paper: &quot;A Gentle Tutorial for Lattice-Based Cryptanalysis&quot; by Joseph Surin and Shaanan Cohney, https://eprint.iacr.org/2023/032</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; minimalpolynomial(3,8.70997594,8,true);
Inputs:
  d=3, β=8.709976, Td=Float64, p=8
Output:
  f(x) = x^3 - 21x^2 + 147x^1 + -348

julia&gt; f,success = minimalpolynomial(3,8.70997594,9); success
false
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/applications.jl#L505-L531">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.partitionintwo"><a class="docstring-binding" href="#LLLplus.partitionintwo"><code>LLLplus.partitionintwo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">x = partitionintwo(a)</code></pre><p>For a vector of integers <code>a</code>, check if the set <code>a</code> can be separated into two sets that each have the same sum. I.e. try to find a binary vector <code>x</code> such that for <code>y = .~ Bool.(x)</code> then <code>x&#39;*a= y&#39;*a. If no such partition is found,</code>missing<code>is returned, otherwise</code>x<code>and</code>y` are returned.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; a = [3,1,1,2,2,1]; # from wikipedia page for Partition Problem

julia&gt; x,y=partitionintwo(a); [x y]
6×2 BitMatrix:
 1  0
 0  1
 0  1
 0  1
 1  0
 0  1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/applications.jl#L588-L610">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.issizereduced"><a class="docstring-binding" href="#LLLplus.issizereduced"><code>LLLplus.issizereduced</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">issizereduced(B)</code></pre><p>Determine if the matrix B is size reduced or not.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];issizereduced(H)
false

julia&gt; B,T = lll(H);issizereduced(B)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/utilities.jl#L117-L131">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.islllreduced"><a class="docstring-binding" href="#LLLplus.islllreduced"><code>LLLplus.islllreduced</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">islllreduced(B)</code></pre><p>Determine if the matrix B is LLL reduced or not. See p 56 of Bremner for a definition. </p><p>M. R. Bremner, &quot;Lattice Basis Reduction: An Introduction to the LLL  Algorithm and Its Applications&quot; CRC Press, 2012.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];islllreduced(H)
false

julia&gt; B,T=lll(H);islllreduced(B)
true
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/utilities.jl#L75-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.orthogonalitydefect"><a class="docstring-binding" href="#LLLplus.orthogonalitydefect"><code>LLLplus.orthogonalitydefect</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">orthogonalitydefect(B)</code></pre><p>Find the orthogonality defect of the matrix B defined, for example, on page 2 of Bennet:</p><p>&quot;An Enumeration Technique for Lattice Basis Reduction&quot; Huck Bennet, 2 Nov</p><ol><li>https://home.cs.colorado.edu/~hbennett/publications/bases.pdf</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];B,T=lll(H);

julia&gt; [orthogonalitydefect(H) orthogonalitydefect(B)]
1×2 Matrix{Float64}:
 7.07107  1.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/utilities.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.hermitefactor"><a class="docstring-binding" href="#LLLplus.hermitefactor"><code>LLLplus.hermitefactor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hermitefactor(B)</code></pre><p>Find the Hermite factor of matrix B</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];hermitefactor(H)
1.5811388300841898
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/utilities.jl#L32-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.seysencond"><a class="docstring-binding" href="#LLLplus.seysencond"><code>LLLplus.seysencond</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seysencond(B)</code></pre><p>Seysen condition number as on, for example, page 3 of Bennet </p><p><a href="https://home.cs.colorado.edu/~hbennett/publications/bases.pdf">Bennet</a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; H= [1 2; 3 4];seysencond(H)
2.8284271247461903
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/utilities.jl#L49-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="LLLplus.gen_qary_b"><a class="docstring-binding" href="#LLLplus.gen_qary_b"><code>LLLplus.gen_qary_b</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">b= gen_qary_b(T, d::Int,k::Int,b::Int)</code></pre><p>Generate a q-ary lattice given an element type <code>T</code>, dimension <code>d</code>, parameter <code>k</code>, and bit-depth <code>b</code>. Specifically, find a <code>d</code> by <code>d</code> matrix which has the block structure <code>[I zeros(T,k,d-k); H q*I]]</code>, where the <code>k</code> by <code>d-k</code> matrix H is sampled from <code>0:q-1</code> and q is sampled uniformly from <code>1:big(2)^b-1</code></p><p>These bases correspond to the SIS/LWE q-ary lattices; see D. Micciancio and O. Regev. Post-Quantum Cryptography. Chapter of Lattice-based Cryptography, 147-191 (2009) and latticegen in https://github.com/fplll/fplll</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; b=gen_qary_b(Int64,2,1,6)
2×2 Matrix{Int64}:
 1   0
 7  32
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/chrisvwx/LLLplus.jl/blob/9dc907be7836bd8458e819059adc0c4142b82648/src/latticegen.jl#L17-L37">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 16 February 2026 03:17">Monday 16 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
