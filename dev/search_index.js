var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"functions/#LLLplus.lll","page":"Functions","title":"LLLplus.lll","text":"B,T,Q,R = lll(H,δ=3/4)\n\nDo Lenstra–Lenstra–Lovász lattice reduction of the basis defined by the columns of H using optional parameter δ.  The output is B, an LLL-reduced basis; T, a unimodular (meaning det(T)=+/-1) transformation matrix such that B= H*T; and finally Q and R which are a QR decomposition of B.  So H = B*inv(T) = Q*R*inv(T).\n\nFollows D. Wuebben, et al, \"Lattice Reduction - A Survey with Applications in Wireless Communications\", IEEE Signal Processing Magazine, Apr 2011.  http://www.ant.uni-bremen.de/sixcms/media.php/102/10740/SPM2011Wuebben.pdf\n\nThe LLL tecnique was originally described in \"Factoring polynomials with rational coefficients\" by A. K. Lenstra, H. W. Lenstra Jr. and L. Lovász, Mathematische Annalen 261, 1982. http://ftp.cs.elte.hu/~lovasz/scans/lll.pdf\n\nExamples\n\njulia> H= [1 2; 3 4];B,_ = lll(H); B\n2×2 Matrix{Int64}:\n 1  -1\n 1   1\n\njulia> H= BigFloat.([1.5 2; 3 4]) .+ 2im; B,_= lll(H); B\n2×2 Matrix{Complex{BigFloat}}:\n 0.5+0.0im  0.0+1.0im\n 1.0+0.0im  0.0+0.0im\n\njulia> N=500;H = randn(N,N); B,T = lll(H);\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.cvp","page":"Functions","title":"LLLplus.cvp","text":"u=cvp(y,R,...)\n\nThis function is deprecated and will likely have its return value change in the future; please use cvpRu if you want to keep the previous return API.\n\n\"CVP\" stands for \"closest vector problem.\"  Unfortunately, at present this function does not return the closest vector to y in the lattice R, but the integer vector u such that multiplying the basis R by this integer vector (i.e. Ru) gives the closest vector. To avoid confusion, in the future the return value will be changed to be Ru, i.e. the closest vector.\n\nSwitch to the function cvpu to get u as the return value, and the function cvpRu to get the closest vector.\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.brun","page":"Functions","title":"LLLplus.brun","text":"B, T = brun(H)\n\nBrun's integer-relations alg implemented as a matrix decomposition. Takes as input the matrix H and returns a reduced basis B and T, a unimodular transformation matrix such that B = H*T. Brun reduction is often done with pinv(H) as input to yield B = pinv(H)*T.\n\nSee V. Brun, \"En generalisation av kjedebrøken I,\" Skr. Vid ensk. Selsk. Kristiana, Mat. Nat. Klasse, 1919.  See https://archive.org/stream/skrifterutgitavv201chri#page/300/mode/2up\n\nFollows code from D. Wuebben, D. Seethaler, J. Jalden, and G. Matz, \"Lattice Reduction - A Survey with Applications in Wireless Communications\" IEEE Signal Processing Magazine, March 2011\n\nExamples\n\njulia> H=[1 2; 3 4]; B,T=brun(H); T\n2×2 Matrix{Int64}:\n  3  -1\n -2   1\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.gauss","page":"Functions","title":"LLLplus.gauss","text":"B = gauss(H)\n\nDo Gauss/Lagrange reduction on the lattice defined by the two columns of H.\n\nFollows Fig 2.3 of \"Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications\" by Murray R. Bremner, CRC Press, 2012.\n\nExamples\n\njulia> H = [1 2; 3 3]; B = gauss(H)\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  3.0\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.seysen","page":"Functions","title":"LLLplus.seysen","text":"B,T,B_dual,num_it = seysen(H::Array{Td,2}) where Td\n\nDo greedy  Seysen lattice reduction  on the  matrix H, returning  B, the reduced lattice basis;  T a unimodular matrix that reduces  H (i.e. B = H*T); B_dual, dual lattice basis (i.e., B_dual = pinv(B)); and num_it the number of iterations (basis updates). See also lll.\n\nFollows Seysen algorithm in \"Lattice Reduction - A Survey with Applications in Wireless Communications\" by D. Wuebben, et al, IEEE Signal Processing Magazine, 2011.\n\nTechnique originally described in \"Simultaneous reduction of a lattice basis and its reciprocal basis\" by M. Seysen, Combinatorica, 1993. http://link.springer.com/article/10.1007%2FBF01202355\n\nExamples\n\njulia> H= [1 2; 3 4];B,T = seysen(H); B\n2×2 Matrix{Int64}:\n -1  1\n  1  1\n\njulia> H= BigFloat.([1.5 2; 3 4]) .+ 2im; B,_= seysen(H); B\n2×2 Matrix{Complex{BigFloat}}:\n 0.0+1.0im  0.5+0.0im\n 0.0+0.0im  1.0+0.0im\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.vblast","page":"Functions","title":"LLLplus.vblast","text":"W,P,B = vblast(H)\n\nFind a VBLAST decomposition of H such that H = pinv(W)*B*P' or B = W*H*P.  Here P is a permutation matrix, B is lower triangular with ones on the diagonal, and W has orthogonal rows.\n\nW,P,B = vblast(H,mu)\n\nIf an SNR argument mu is passed in, a regularized (\"MMSE\") decomposition is done, with the result that W will no longer have orthogonal rows and B is no longer lower triangular.\n\nExamples\n\njulia> H= [1. 2; 3 4];W,_ = vblast(H); W\n2×2 Matrix{Float64}:\n 1.5  -0.5\n 0.1   0.3\n\njulia> H= BigFloat.([1.5 2; 3 4]) .+ 2im; W,_= vblast(H); W\n2×2 Matrix{Complex{BigFloat}}:\n      -2.0+3.0im            2.0-1.5im     \n 0.0779221-0.103896im  0.155844-0.103896im\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.subsetsum","page":"Functions","title":"LLLplus.subsetsum","text":"x = subsetsum(a,s)\n\nFor a vector of integers a, and an integer s, try to find a binary vector x such that x'*a=s. We use the LLL algorithm to find the solution. This is not a robust tool, just a demo.\n\nThis function tries first the technique in the lagariasodlyzko function, and if it fails, a solution via mdsubsetsum is attempted.\n\nIt appears that this function can also solve some integer relations problems. See the first example.\n\nExamples\n\njulia> a=[1.5;.5;0;.1;.2]; s=2.2; x,_=subsetsum(a,s,true); s-x'*a\nA binary Lagarias-Odlyzko solution was found.\nA solution was found via lagariasodlyzko\n0.0\n\njulia> a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117\n          2097523,4195057,8390143,16780259,33560539,\n          67121039,134242091,268484171,536968403];\n\njulia> s=891221976; x,_=subsetsum(a,s,false); s-x'*a\n0\n\njulia> N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a'*xtrue;\n\njulia> setprecision(BigFloat,300); x,_=subsetsum(a,s,false); s-x'*a\n0\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.lagariasodlyzko","page":"Functions","title":"LLLplus.lagariasodlyzko","text":"x = lagariasodlyzko(a,s)\n\nFor a vector of integers a, and an integer s, try to find a binary vector x such that x'*a=s. We use the LLL algorithm to find the solution. This is not a robust tool, just a demo.\n\nThis follows the technique described by Lagarias and Odlyzko  in  \"Solving Low-Density Subset Sum Problems\"  in Journal of ACM, Jan 1985. Code based on http://web.eecs.umich.edu/~cpeikert/lic15/lec05.pdf We can likely get better results using techniques described and referenced in https://www-almasty.lip6.fr/~joux/pages/papers/ToolBox.pdf\n\nIt's odd that permuting the a vector in the second example given below causes the alg to often not find a binary solution. Apparently this is a common oddity with lattice solvers.\n\nExamples\n\njulia> a=[1.5;.5;0;.1;.2]; s=2.2; x,_=lagariasodlyzko(a,s); s-x'*a\n0.0\n\njulia> a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117\n          2097523,4195057,8390143,16780259,33560539,\n          67121039,134242091,268484171,536968403];\n\njulia> s=891221976; x,_=lagariasodlyzko(a,s); s-x'*a\n0\n\njulia> N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a'*xtrue; \n\njulia> setprecision(BigFloat,300); x,_=lagariasodlyzko(a,s); s-x'*a\n0\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.mdsubsetsum","page":"Functions","title":"LLLplus.mdsubsetsum","text":"x = mdsubsetsum(a,sM,ratio=.5,Kpm=3)\n\nFor a vector of integers a, and an integer sM, try to find a binary vector x such that x'*a=sM using the technique from \"Multidimensional subset sum problem\" [1][2]. A major goal of the technique is to solve problems in which there are about 50% ones in x; other ratios of ones to zeros can be specified in ratio.  The thesis also suggests searching Kpm=3 values around the nominal k. This technique is related to that in subsetsum in that both use the LLL algorithm.  This is not a robust tool, just a demo.\n\n[1] https://scholarworks.rit.edu/theses/64/\n\n[2] https://pdfs.semanticscholar.org/21a7/c2f9ff29507f1153aefcca04d1cd308e45c0.pdf\n\nExamples\n\njulia> using Random, LLLplus\n\njulia> a=[1.5;.5;0;.1;.2]; s=2.2; x=mdsubsetsum(a,s); s-x'*a\n0.0\n\njulia> a=[32771,65543,131101,262187,524387,1048759, # from Bremner p 117\n          2097523,4195057,8390143,16780259,33560539,\n          67121039,134242091,268484171,536968403];\n\njulia> sM=891221976; x=mdsubsetsum(a,sM); sM-x'*a\n0\n\njulia> setprecision(BigFloat,300); Random.seed!(0);\n\njulia> N=40;a=rand(1:2^BigInt(256),N);xtrue=rand(Bool,N); s=a'*xtrue;\n\njulia> x=mdsubsetsum(a,s); s-x'*a\n0\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.integerfeasibility","page":"Functions","title":"LLLplus.integerfeasibility","text":"integerfeasibility(A,d)\n\nGiven matrix A and vector d, return an integer vector x which satisfies the system Ax=d.\n\nintegerfeasibility(A,d,true)\n\nIf the third argument is present and is true, then as well as returning a solution x, also return a matrix xNull of vectors in the null space of A which could be added to the x vector to find a solution which satisfies a constraint such as 0 .≤ x .≤ u; see the paper below.\n\nThis is not a robust tool, just a demo.\n\n\"Solving A System Of Diophantine Equations With Bounds On The Variables\" by Karen Aardal, Cor Hurkens, and Arjen Lenstra in Integer Programming and Combinatorial Optimization, 6th International IPCO Conference, vol 1412, pp 229-242, 1998. See http://softlib.rice.edu/pub/CRPC-TRs/reports/CRPC-TR98782.pdf\n\nExamples\n\njulia> A=[10 1 -9; 1 8 8]; xtrue=[0; 2; 9]; d=A*xtrue;\n\njulia> integerfeasibility(A,d)\n3-element Vector{Int64}:\n 0\n 2\n 9\n\njulia> A=[10 1.1 -9.1; 1 8 8]; d=A*xtrue;\n\njulia> integerfeasibility(A,d)\n3-element Vector{Float64}:\n 0.0\n 2.0\n 9.0\n\njulia> n=20;m=30; A = rand(-10:10,n,m); xtrue = rand(0:10,m); d=A*xtrue;\n\njulia> sum(abs.(xtrue - integerfeasibility(A,d) ))\n0\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.rationalapprox","page":"Functions","title":"LLLplus.rationalapprox","text":"rationalapprox(x::AbstractArray{<:Real,1},M,Ti=BigInt,verbose=false)\n\nFor a vector of Reals x, and an integer M, find an integer q such that maximum(abs.(x*q-round.(x*q))) is small; the vector x is approximated by round.(x*q)//q.  The integer q is less than or equal to M and the approximation satisfies max(abs.(x*q-round.(x*q)))≤sqrt(5)*2^(n/4 - 5)*M^(-1/n); this equation comes from the paper below.  The LLL algorithm reduction is used to find the solution. The approximation vector is returned. This is also known as \"simultaneous diophantine approximation\"; see for example the Hanrot paper below.\n\nThis is not a robust tool, just a demo.\n\n\"LLL: A Tool for Effective Diophantine Approximation\" by Guillaume Hanrot in the book \"The LLL Algorithm: Survey and Applications\" edited by Phong Q. Nguyen and Brigitte Vallée, Springer, Heidelberg, 2010.\n\nSee also Chapter 9 of M. R. Bremner, \"Lattice Basis Reduction: An Introduction to the LLL Algorithm and Its Applications\" CRC Press, 2012.\n\nExamples\n\njulia> x = [0.3912641745333527; 0.5455179974014548; 0.1908698210882469];\n\njulia> rationalapprox(x,1e4,Int64)\n3-element Vector{Rational{Int64}}:\n 43//110\n  6//11\n 21//110\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.spigotBBP","page":"Functions","title":"LLLplus.spigotBBP","text":"spigotBBP(α::Td,s,b,n,K,verbose=false) where {Td}\n\nCheck for a BBP-style [1] infinite series for the constant α.  These are \"spigot\" formulas that can be used to generate (for example) the millionth digit of the constant α without learning the previous digits. Specifically, given the constant α, and parameters b, n, and s, look for a vector of numbers a_1 through a_n that satisfies the following equation:\n\nalpha= sum_k=0^infty frac1b^k left( fraca_1(nk+1)^s + ldots + fraca_n(nk+n)^s right)\n\nBecause it's hard to sum to infinity, the sum is stopped at K. If a formula is found, it is printed to the screen in LaTeX and the coefficents a are returned as a vector.  An online LaTeX viewer such as https://www.latex4technics.com/ may be helpful.\n\nThis is not a robust tool, just a demo. For example, there may be a  problem with s≥2. See [2] for derivation of the technique used, and to  check whether a formula you find is new.\n\n[1] David Bailey, Peter Borwein, and Simon Plouffe. \"On the rapid computation of various polylogarithmic constants.\" Mathematics of Computation 66.218 (1997): 903-913. https://www.ams.org/journals/mcom/1997-66-218/S0025-5718-97-00856-9/\n\n[2] David Bailey, \"A Compendium of BBP-Type Formulas for Mathematical Constants\". https://www.davidhbailey.com//dhbpapers/bbp-formulas.pdf\n\nExample\n\njulia> spigotBBP(BigFloat(pi),1,16,8,45,true);\nA solution was found w error -4.728672e-60. In LaTeX form it is\n\\alpha= \\sum_{k=0}^\\infty \\frac{1}{16^k} \\left(\\frac{4}{8k+1}-\\frac{2}{8k+4}-\\frac{1}{8k+5}-\\frac{1}{8k+6}\\right)\n\nOther examples without output:\n\nspigotBBP(Float64(pi),1,-4,4,22,true);\nspigotBBP(log(2),1,2,2,30,true);\nspigotBBP(9*log(3),1,9,2,30,true);\nspigotBBP(atan(2)*8,1,16,8,30,true);\nspigotBBP(8*sqrt(2)*log(1+sqrt(2)),1,16,8,25,true);\n\nThere is a formula for pi^2 which the following command should find, but it does not find it. In fact the technique doesn't seem to work at all for  s>2; It's not obvious what the problem is\n\nspigotBBP(BigFloat(pi)*pi,2,64,6,25,true);\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.minimalpolynomial","page":"Functions","title":"LLLplus.minimalpolynomial","text":"minimalpolynomial(d,β::Td,p,verbose=false) where {Td<:Number}\n\nFind the minimal polynomial for some element 'α' of a field given the degree 'd' of the polynomial, an approximation 'β' of 'α', and the number of significant (decimal) digits of precision 'p' in 'β'. Returns two things, a function, and a Bool indicating whether we think a true minimal polynomial was found.  The ouptut function takes a single argument of the same type as 'β', and evaluates the estimated minimal polynomial over that argument.\n\nFollows technique in the following paper: \"A Gentle Tutorial for Lattice-Based Cryptanalysis\" by Joseph Surin and Shaanan Cohney, https://eprint.iacr.org/2023/032\n\nExample\n\njulia> minimalpolynomial(3,8.70997594,8,true);\nInputs:\n  d=3, β=8.709976, Td=Float64, p=8\nOutput:\n  f(x) = x^3 - 21x^2 + 147x^1 + -348\n\njulia> f,success = minimalpolynomial(3,8.70997594,9); success\nfalse\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.partitionintwo","page":"Functions","title":"LLLplus.partitionintwo","text":"x = partitionintwo(a)\n\nFor a vector of integers a, check if the set a can be separated into two sets that each have the same sum. I.e. try to find a binary vector x such that for y = .~ Bool.(x) then x'*a= y'*a. If no such partition is found,missingis returned, otherwisexandy` are returned.\n\nExamples\n\njulia> a = [3,1,1,2,2,1]; # from wikipedia page for Partition Problem\n\njulia> x,y=partitionintwo(a); [x y]\n6×2 BitMatrix:\n 1  0\n 0  1\n 0  1\n 0  1\n 1  0\n 0  1\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.issizereduced","page":"Functions","title":"LLLplus.issizereduced","text":"issizereduced(B)\n\nDetermine if the matrix B is size reduced or not.\n\nExamples\n\njulia> H= [1 2; 3 4];issizereduced(H)\nfalse\n\njulia> B,T = lll(H);issizereduced(B)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.islllreduced","page":"Functions","title":"LLLplus.islllreduced","text":"islllreduced(B)\n\nDetermine if the matrix B is LLL reduced or not. See p 56 of Bremner for a definition. \n\nM. R. Bremner, \"Lattice Basis Reduction: An Introduction to the LLL  Algorithm and Its Applications\" CRC Press, 2012.\n\nExamples\n\njulia> H= [1 2; 3 4];islllreduced(H)\nfalse\n\njulia> B,T=lll(H);islllreduced(B)\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.orthogonalitydefect","page":"Functions","title":"LLLplus.orthogonalitydefect","text":"orthogonalitydefect(B)\n\nFind the orthogonality defect of the matrix B defined, for example, on page 2 of Bennet:\n\n\"An Enumeration Technique for Lattice Basis Reduction\" Huck Bennet, 2 Nov\n\nhttps://home.cs.colorado.edu/~hbennett/publications/bases.pdf\n\nExamples\n\njulia> H= [1 2; 3 4];B,T=lll(H);\n\njulia> [orthogonalitydefect(H) orthogonalitydefect(B)]\n1×2 Matrix{Float64}:\n 7.07107  1.0\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.hermitefactor","page":"Functions","title":"LLLplus.hermitefactor","text":"hermitefactor(B)\n\nFind the Hermite factor of matrix B\n\nExamples\n\njulia> H= [1 2; 3 4];hermitefactor(H)\n1.5811388300841898\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.seysencond","page":"Functions","title":"LLLplus.seysencond","text":"seysencond(B)\n\nSeysen condition number as on, for example, page 3 of Bennet \n\nBennet\n\nExamples\n\njulia> H= [1 2; 3 4];seysencond(H)\n2.8284271247461903\n\n\n\n\n\n\n","category":"function"},{"location":"functions/#LLLplus.gen_qary_b","page":"Functions","title":"LLLplus.gen_qary_b","text":"b= gen_qary_b(T, d::Int,k::Int,b::Int)\n\nGenerate a q-ary lattice given an element type T, dimension d, parameter k, and bit-depth b. Specifically, find a d by d matrix which has the block structure [I zeros(T,k,d-k); H q*I]], where the k by d-k matrix H is sampled from 0:q-1 and q is sampled uniformly from 1:big(2)^b-1\n\nThese bases correspond to the SIS/LWE q-ary lattices; see D. Micciancio and O. Regev. Post-Quantum Cryptography. Chapter of Lattice-based Cryptography, 147-191 (2009) and latticegen in https://github.com/fplll/fplll\n\nExample\n\njulia> b=gen_qary_b(Int64,2,1,6)\n2×2 Matrix{Int64}:\n 1   0\n 7  32\n\n\n\n\n\n\n","category":"function"},{"location":"#LLLplus-README","page":"Home","title":"LLLplus README","text":"LLLplus provides lattice tools such as Lenstra-Lenstra-Lovász (LLL) lattice reduction which are of practical and theoretical use in cryptography, digital communication, integer programming, and more. This package is experimental and not a robust tool; use at your own risk :-)\n\nLLLplus has functions for LLL, Seysen, and Hermite-Korkine-Zolotarev lattice reduction techniques. Brun integer relations is included in the form of lattice reduction. Solvers for the shortest vector and the closest vector problems are also included; for more see the help text for the lll, seysen, hkz, brun, svp, and cvp functions. Several toy (demo) functions are also included; see the  subsetsum, minimalpolynomial, integerfeasibility, rationalapprox, and  spigotBBP functions.","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"Each function contains documentation and examples available via Julia's built-in documentation system (try ?lll or @doc(lll)). Documentation for all functions is available. A tutorial notebook is found in the docs directory or on nbviewer.\n\nHere are a few examples of using the functions in the package on random lattices.\n\nPkg.add(\"LLLplus\")\nusing LLLplus\n\n# do lattice reduction on a matrix with randn entries\nN = 40;\nH = randn(N,N);\nBbrun,_ = brun(H);\nBlll,_ = lll(H);\nBseysen,_ = seysen(H);\nBhkz,_ = hkz(H);\n\n# check out the CVP solver\nQ,Rtmp=qr(H); R = UpperTriangular(Rtmp);\nu=Int.(rand(0:1e10,N));\ny=H*u+rand(N)/100;\nuhat=cvp(Q'*y,R);\nsum(abs.(u-uhat))","category":"section"},{"location":"#Execution-Time-results","page":"Home","title":"Execution Time results","text":"To give a flavor of the behavior of the functions in LLLplus, we show execution time for several built-in datatypes (Int32, Int64, Int128, Float32, Float64, BitInt, and BigFloat) as well as type from external packages (Float128 from Quadmath.jl and Double64 from DoubleFloat.jl) which are used to generate 100 16x16 matrices with elements uniformly distributed over -100 to 100. The figure shows average execution time when using these matrices as input lattice bases for several functions from LLLplus. See test/perftest.jl for the code to regenerate the figure and for another line of code that generates a figure of execution time versus basis dimension.\n\n(Image: Time vs data type)","category":"section"},{"location":"#Notes","page":"Home","title":"Notes","text":"The 2020 Simons Institute lattice workshop, a survey paper by Wuebben, and the monograph by Bremner  were helpful in writing the tools in LLLplus and are good resources for further study. If you are trying to break one of the Lattice Challenge records or are looking for robust, well-proven lattice tools, look at fplll. Also, for many number-theoretic problems the Nemo.jl package is appropriate; it uses the FLINT C library to do LLL reduction on Nemo-specific data types.  Finally, no number theorists have worked on LLLplus; please treat the package as experimental.","category":"section"}]
}
